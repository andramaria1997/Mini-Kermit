# Mini-Kermit

		README

	I created two structures: one for initiate data, helpful for creating the type S package containing maxl, time, npad, padc, eol, qctl, qbin, chkt, rept, capa and r, and one for the kermit package: soh, len, seq, type.
	First thing needed was a function to create packages. Since the data field for the 'S' package was so different from all the others, it seemed a good idea to make a separate function for type 'S' ( make_S_pack(type, maxl, time, seq) ) whici creates a pack with the parameters decided when initiating the connection (stores the necessary data into the structure and returns it). In the same way, the function make_pack(seq, type, data) creates a package by need.
	All packages are send and received by using two main functions: send_package(package) and recieve_package(*ack);

	---> int send_package ( kermit package ) - > returns the sequence number of currently send package; puts the packet in the payload, sets the length of the payload, then sends it; the function then waits for and ack; if it does not receive it, the package will be send again; else, the CRC of ack is checked; if ok, the next step is to look if it is an ack or a nak; in case of a nak, the package is resent; otherwise, it goes further to the next package; all these steps are reproduced for one single pack until three consecutive identical failures (3 packs lost or 3 nak packs), case in which the transmission is ended
	---> kermit receive_package ( kermit *package ) - > it stores the previous ack by side effect - parameter *package - and returns the pack recieved from sender to be written in file; as a first step, the function waits for a pack to be recieved (for 5 sec, then it is considered timeout); if it recieves nothing, the pack is considered lost and the receiver sends again the previous ack or nak (this is where the parameter makes sense); when the pack arrives, the checksum is verified; if wrong, the function sends a nak; otherwise, the next thing to be checked is the sequence number; the reciever is expecting one specific sequence number - the next one after what it just received; so, in case they differ, the pack is dropped in order of preventing duplicates; then, if the sequence number is ok too, an ack is sent;

	The effective transmission is made by calling the previous explained functions. First, a pack of type 'S' is sent, for setting convenient parameters for both sender and receiver. Then, the receiver waits for packages to come until it comes accross a type 'B' package, which means end of transmission. Files are delimited with packs of type 'F' for headers, and type 'Z' for EOF. The sender will send actual data while it does not detect an EOF, and the receiver will write actual data while it does not detect package 'Z'.
